"""
Generate HTML standings page based on Codeforces design
"""
from typing import Dict, List, Optional
from data.configs_reader import DIR


HTML_TEMPLATE = """<!DOCTYPE html>
<html lang="ru">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{contest_name} - Standings</title>
    <style>
        body {{
            font-family: 'Lucida Grande', 'Lucida Sans Unicode', 'Lucida Sans', Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }}
        
        .container {{
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }}
        
        .contest-name {{
            font-size: 1.5em;
            color: #445f9d;
            text-align: center;
            margin: 20px 0;
            font-weight: bold;
        }}
        
        .contest-status {{
            text-align: center;
            color: #888;
            margin-bottom: 20px;
        }}
        
        table.standings {{
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }}
        
        table.standings th {{
            background-color: #e1e1e1;
            padding: 8px;
            text-align: center;
            font-weight: bold;
            border: 1px solid #ccc;
        }}
        
        table.standings th.top {{
            background-color: #d0d0d0;
        }}
        
        table.standings td {{
            padding: 8px;
            text-align: center;
            border: 1px solid #e1e1e1;
        }}
        
        table.standings tr:nth-child(odd) td {{
            background-color: #fafafa;
        }}
        
        table.standings tr:nth-child(even) td {{
            background-color: #fff;
        }}
        
        table.standings tr.dark td {{
            background-color: #f0f0f0;
        }}
        
        .contestant-cell {{
            text-align: left !important;
            padding-left: 1em !important;
        }}
        
        .cell-accepted {{
            color: #0a0;
            font-weight: bold;
        }}
        
        .cell-rejected {{
            color: #00a;
        }}
        
        .cell-time {{
            font-size: 0.9em;
            display: block;
            color: #666;
        }}
        
        .highlighted-row {{
            background-color: #ffffcc !important;
        }}
        
        th a {{
            color: #445f9d;
            text-decoration: none;
        }}
        
        th a:hover {{
            text-decoration: underline;
        }}
        
        .standings-flag {{
            width: 16px;
            height: 11px;
            margin-right: 5px;
            vertical-align: middle;
        }}
        
        .info-text {{
            text-align: right;
            color: #888;
            font-size: 0.9em;
            margin-bottom: 10px;
        }}
        
        .left {{
            text-align: left;
        }}
        
        .right {{
            text-align: right;
        }}
    </style>
</head>
<body>
    <div class="container">
        <div class="contest-name">
            {contest_name}
        </div>
        <div class="contest-status">Результаты</div>
        
        <div class="info-text">
            Generated by CF Tools Bot
        </div>
        
        <table class="standings">
            <tr>
                <th class="top left" style="width:2em;">№</th>
                <th class="top" style="text-align:left;">Кто</th>
                <th class="top" style="width:2em;">=</th>
                <th class="top" style="width:4em;">Штраф</th>
                {problem_headers}
            </tr>
            {rows}
        </table>
    </div>
</body>
</html>
"""


def format_time(seconds: int) -> str:
    """Format time in seconds to HH:MM format"""
    hours = seconds // 3600
    minutes = (seconds % 3600) // 60
    return f"{hours:02d}:{minutes:02d}"


def generate_problem_headers(problems: List[Dict]) -> str:
    """Generate HTML for problem headers"""
    headers = []
    for i, problem in enumerate(problems):
        problem_letter = problem.get('index', chr(65 + i))
        problem_name = problem.get('name', f'Problem {problem_letter}')
        headers.append(
            f'<th class="top" style="width:4em;">'
            f'<span title="{problem_name}">{problem_letter}</span>'
            f'</th>'
        )
    # Add right class to last header
    if headers:
        headers[-1] = headers[-1].replace('<th class="top"', '<th class="top right"')
    return '\n                '.join(headers)


def generate_row(rank: int, participant_name: str, solved: int, penalty: int, 
                 problems: List[Dict], is_dark: bool = False) -> str:
    """Generate HTML for a single row"""
    dark_class = "dark " if is_dark else ""
    cells = []
    
    # Rank
    cells.append(f'<td class="{dark_class}left">{rank if rank > 0 else ""}</td>')
    
    # Participant name
    cells.append(f'<td class="contestant-cell {dark_class}" style="text-align:left;padding-left:1em;">'
                f'{participant_name}</td>')
    
    # Solved problems
    cells.append(f'<td class="{dark_class}">{solved}</td>')
    
    # Penalty
    penalty_str = str(penalty) if penalty > 0 else "&nbsp;"
    cells.append(f'<td class="{dark_class}">{penalty_str}</td>')
    
    # Problem cells
    for i, problem in enumerate(problems):
        cell_class = dark_class
        if i == len(problems) - 1:
            cell_class += "right"
        
        if problem.get('accepted'):
            attempts = problem.get('attempts', 0)
            time_str = format_time(problem.get('time', 0))
            attempts_str = f"+{attempts}" if attempts > 1 else "+"
            cell_content = (
                f'<span class="cell-accepted">{attempts_str}</span>'
                f'<span class="cell-time">{time_str}</span>'
            )
        elif problem.get('attempts', 0) > 0:
            cell_content = f'<span class="cell-rejected">-{problem["attempts"]}</span>'
        else:
            cell_content = '<span class="cell-rejected">&nbsp;</span>'
        
        cells.append(f'<td class="{cell_class}">{cell_content}</td>')
    
    return f'    <tr>\n        {"\n        ".join(cells)}\n    </tr>'


def generate_html_standings(contest_name: str, standings_data: List[Dict], 
                            problem_list: List[Dict], custom_names: Optional[Dict[str, str]] = None) -> str:
    """
    Generate HTML standings page
    
    Args:
        contest_name: Name of the contest
        standings_data: List of participant standings [{
            'participant': str,
            'rank': int,
            'solved': int,
            'penalty': int,
            'problems': [{
                'accepted': bool,
                'attempts': int,
                'time': int (seconds)
            }]
        }]
        problem_list: List of problems [{'index': 'A', 'name': 'Problem A'}, ...]
        custom_names: Optional dict to map anonymous names to real names
        
    Returns:
        HTML string
    """
    problem_headers = generate_problem_headers(problem_list)
    
    rows = []
    for i, standing in enumerate(standings_data):
        participant_name = standing['participant']
        
        # Apply custom names if available
        if custom_names and participant_name in custom_names:
            if custom_names[participant_name]:  # Only replace if not None
                participant_name = custom_names[participant_name]
        
        row_html = generate_row(
            rank=standing.get('rank', i + 1),
            participant_name=participant_name,
            solved=standing.get('solved', 0),
            penalty=standing.get('penalty', 0),
            problems=standing.get('problems', []),
            is_dark=(i % 2 == 1)
        )
        rows.append(row_html)
    
    html = HTML_TEMPLATE.format(
        contest_name=contest_name,
        problem_headers=problem_headers,
        rows='\n'.join(rows)
    )
    
    return html


def standings_from_codeforces_api(api_data: Dict, custom_names: Optional[Dict[str, str]] = None) -> str:
    """
    Convert Codeforces API standings data to HTML
    
    Args:
        api_data: Codeforces API response data from contest.standings
        custom_names: Optional dict to map participant names to custom names
        
    Returns:
        HTML string
    """
    result = api_data.get('result', {})
    contest = result.get('contest', {})
    contest_name = contest.get('name', 'Contest Standings')
    
    problems = result.get('problems', [])
    problem_list = [{'index': p['index'], 'name': p.get('name', '')} for p in problems]
    
    rows = result.get('rows', [])
    standings_data = []
    
    for row in rows:
        party = row.get('party', {})
        members = party.get('members', [])
        
        # Get participant name
        participant_name = (
            members[0].get('name') or 
            members[0].get('handle') or 
            party.get('teamName') or 
            f"Participant {row.get('rank', '?')}"
        )
        
        # Get problem results
        problem_results = []
        for problem_result in row.get('problemResults', []):
            points = problem_result.get('points', 0)
            rejected_attempt_count = problem_result.get('rejectedAttemptCount', 0)
            best_submission_time = problem_result.get('bestSubmissionTimeSeconds', 0)
            
            problem_results.append({
                'accepted': points > 0,
                'attempts': rejected_attempt_count + (1 if points > 0 else 0),
                'time': best_submission_time if points > 0 else 0
            })
        
        standings_data.append({
            'participant': participant_name,
            'rank': row.get('rank', 0),
            'solved': int(row.get('points', 0)),
            'penalty': row.get('penalty', 0),
            'problems': problem_results
        })
    
    return generate_html_standings(contest_name, standings_data, problem_list, custom_names)
